#include <omp.h>
#include <stdio.h>
#include <time.h>
#include <iostream>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_vector.h>
#include <gsl/gsl_blas.h>
#include <gsl/gsl_rng.h>

using namespace std;

// random +/- 1
double randsig(gsl_rng *rng);

int n = 16;
int tmax = 50;
double tol = 1e-11;
char caracter;

gsl_matrix *A = gsl_matrix_alloc(n, n);
gsl_vector *b = gsl_vector_alloc(n);

gsl_vector *x = gsl_vector_alloc(n);
gsl_vector *x0 = gsl_vector_alloc(n);
// gerador randÃ´mico
gsl_rng *rng = gsl_rng_alloc(gsl_rng_default);


int main(int argc, char *argv[]) {

    /* This function initializes (or “seeds”) the random number generator. If the generator is seeded with the
     * same value of s on two different runs, the same stream of random numbers will be generated by successive
     * calls to the routines below. If different values of s \geq 1 are supplied, then the generated streams of
     * random numbers should be completely different. If the seed s is zero then the standard seed from the
     * original implementation is used instead. For example, the original Fortran source code for the ranlux
     * generator used a seed of 314159265, and so choosing s equal to zero reproduces this when using gsl_rng_
     * ranlux. When using multiple seeds with the same generator, choose seed values greater than zero to avoid
     * collisions with the default setting. Note that the most generators only accept 32-bit seeds, with higher
     * values being reduced modulo 2^{32}. For generators with smaller ranges the maximum seed value will
     * typically be lower.*/
    gsl_rng_set(rng, time(NULL));
    printf("\nrng = %10lld", rng);
    printf("\nTime now Segundos desde 1900 = %lld", time(nullptr));
    // Inicializacao
    // Matriz estritamente diagonal dominante
    printf("\nInicializacao ... ");
    double sig;
    for (int i = 0; i < n; i++) {
        double s = 0;
        for (int j = 0; j < n; j++) {
            /* double aux = gsl_rng_uniform(rng)
             * This function returns a double precision floating point number uniformly distributed in the range
             * [0,1). The range includes 0.0 but excludes 1.0. The value is typically obtained by dividing the
             * result of gsl_rng_get(r) by gsl_rng_max(r) + 1.0 in double precision. Some generators compute
             * this ratio internally so that they can provide floating point numbers with more than 32 bits
             * of randomness (the maximum number of bits that can be portably represented in a single unsigned
             * long int).*/
            double aux = gsl_rng_uniform(rng);
            gsl_matrix_set(A, i, j, randsig(rng) * aux);
            s += aux;
        }
        gsl_matrix_set(A, i, i, randsig(rng) * s);
        gsl_vector_set(b, i, randsig(rng) * gsl_rng_uniform(rng));
        gsl_vector_set(x0, i, randsig(rng) * gsl_rng_uniform(rng));

    }

    // Print the values of A using GSL print functions
    cout << "\nA = \n";
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            //printf("A(%d,%d) = %g\n", i, j, gsl_matrix_get(A, i, j));
            printf("%6.3f ", gsl_matrix_get(A, i, j));
        }
        printf("\n");
    }

    // Print the values of b using GSL print functions
    cout << "\nb-Transposta = \n";
    for (int i = 0; i < n; i++) {
        printf("%13.10f ", gsl_vector_get(b, i));
    }

    // Print the values of b using GSL print functions
    cout << "\nx0-Transposta = \n";
    for (int i = 0; i < n; i++) {
        printf("%6.3f ", gsl_vector_get(x0, i));
    }


    printf("\nfeito.");

    // Jacobi
    for (int t = 0; t < tmax; t++) {
#pragma omp  parallel  for
        for (int i = 0; i < n; i++) {
            double s = 0;
            // Soma dos elementos a esquerda da diagonal
            for (int j = 0; j < i; j++)
                s += gsl_matrix_get(A, i, j) * gsl_vector_get(x0, j);
             // Soma dos elementos à direita da diagonal principal
            for (int j = i + 1; j < n; j++)
                s += gsl_matrix_get(A, i, j) * gsl_vector_get(x0, j);
            //Calcula o novo valor de x(i)
            gsl_vector_set(x, i, (gsl_vector_get(b, i) - s) / gsl_matrix_get(A, i, i));

        }
        // criterio de parada
        // ||x0-x||_2 < tol

        /* gsl_blas_daxpy($alpha, $x, $y)
         * These functions compute the sum $y = $alpha * $x + $y for the vectors $x and $y*/
        gsl_blas_daxpy(-1.0, x, x0); //x0:=x0-x

        /* double gsl_blas_dnrm2(const gsl_vector * x)
         * These functions compute the Euclidean norm ||x||_2 = \sqrt{\sum x_i^2} of the vector x.*/
        double e = gsl_blas_dnrm2(x0);

        printf("\nIter. %d: %1.0e", t, e);

        if (e < tol)
            break;
       /* int gsl_vector_memcpy(gsl_vector * dest, const gsl_vector * src)
        * This function copies the elements of the vector src into the vector dest.
        * The two vectors must have the same length.*/
        gsl_vector_memcpy(x0, x); // x0:=x
        // Atualiza x0 para uma nova atualização de x pelo método Jacobi
    }

    // Print the values of b using GSL print functions
    cout << "\nx-Transposta = \n";
    for (int i = 0; i < n; i++) {
        printf("%6.3f ", gsl_vector_get(x, i));
    }

    // Print the values of b using GSL print functions
    cout << "\nAx = \n";
    for (int i = 0; i < n; i++) {
        double s = 0;
        for (int j = 0; j < n; j++) {
            s = s +gsl_matrix_get(A,i,j)*gsl_vector_get(x,j);
        }
        printf("\nAx=%13.10f  eo Erro(Ax-b)= %13.10f",s,s-gsl_vector_get(b,i));
    }

    gsl_matrix_free(A);
    gsl_vector_free(b);
    gsl_vector_free(x);
    gsl_vector_free(x0);
    gsl_rng_free(rng);

    cout << "\n\n Tecle uma tecla e apos Enter para finalizar...\n";
    cin >> caracter;

    return 0;
}

double randsig(gsl_rng *rng) {
    double signal = 1.0;
    if (gsl_rng_uniform(rng) >= 0.5)
        signal = -1.0;
    return
            signal;
}